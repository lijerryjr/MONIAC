###################
# MONIAC.py game
# This is the main file where the game is run
###################

## Imports
import math
import numpy as np

from tkinter import *
import tkinter

import string

from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg, 
                                               NavigationToolbar2Tk)
from matplotlib.backend_bases import key_press_handler
from matplotlib.figure import Figure
from matplotlib import style

import textFunctions
from textFunctions import (replaceWhiteSpace, breakLines, 
                           removeTrailingSpaces, createNewText, 
                           rightJustifyText)

import mathFunctions
from mathFunctions import (distance, magnitude, roundUp)

## Sand, Wall, Variable, and Button Objects
class Sand(object):
    #Creates sand object with position and directional changes
    def __init__(self, cx, cy, r, dx, dy, boing, color='yellow'):
        self.cx=cx
        self.cy=cy
        self.r=r
        self.dx=dx
        self.dy=dy
        if dx==0:
            self.angle=3*math.pi/2
        else:
            self.angle=math.atan(abs(self.dy)/abs(self.dx))
        self.boing=boing
        self.color=color
    def __str__(self):
        return "%0.1f %0.1f" %(self.dx, self.dy)
    def draw(self, canvas):
        canvas.create_oval(self.cx-self.r, self.cy-self.r, self.cx+self.r, 
                           self.cy+self.r, fill=self.color)
    def move(self):
        self.cx+=math.cos(math.radians(self.angle))*self.dx
        self.cy+=math.sin(math.radians(self.angle))*self.dy
    def moveX(self):
        self.cx+=math.cos(math.radians(self.angle))*self.dx
    def unmoveX(self):
        self.dx = - self.dx
        self.cx += math.cos(math.radians(self.angle))*self.dx
        #self.dx *= self.boing
    def unmoveY(self):
        self.dy = - self.dy
        self.cy += math.sin(math.radians(self.angle))*self.dy
        self.dy *= self.boing
    def collides(self, other):
        #Check if sand collides with a wall
        smallX=min([other.x1, other.x2])
        largeX=max([other.x1, other.x2])
        smallY=min([other.y1, other.y2])
        largeY=max([other.y1, other.y2])
        if (smallX>self.cx+self.r or largeX<self.cx-self.r or 
            smallY>self.cy+self.r or largeY<self.cy-self.r):
            #Edge case
            return False
        #Use vectors to calculate angle and height to check distance
        u=(other.x1-other.x2, other.y1-other.y2)
        v=(self.cx-other.x1, self.cy-other.y1)
        product=(u[0]*v[0]+u[1]*v[1])/(magnitude(u)*magnitude(v))
        angle=math.acos(product)
        h=distance(self.cx, self.cy, other.x1, other.y1)*math.sin(angle)
        if h<=self.r:
            return True
        else:
            return False
    def updateAngle(self):
        if self.dx==0:
            self.angle=3*math.pi/2
        else:
            self.angle=math.atan(abs(self.dy)/abs(self.dx))
    
class Wall(object):
    #Create wall object represented as a line
    def __init__(self, x1, y1, x2, y2):
        self.x1=x1
        self.y1=y1
        self.x2=x2
        self.y2=y2
        #Calculate slope
        if x1==x2:
            self.slope=0
        else: self.slope=(y2-y1)/(x2-x1)
        #Calculate angle
        if x2-x1==0:
            self.angle=3*math.pi/2
        else:
            self.angle=math.atan((y2-y1)/(x2-x1))
    def draw(self, canvas):
        canvas.create_line(self.x1, self.y1, self.x2, self.y2)

class Label(object):
    def __init__(self, name, xPos, yPos, color):
        self.name=name
        self.xPos=xPos
        self.yPos=yPos
        self.color=color
    def draw(self, canvas):
        canvas.create_text(self.xPos, self.yPos, text=self.name, 
                           fill=self.color)

## Button objects, change drawPage and isClicked functions to take in data
#isclicked-->modify data.isPaused and data.clickedButton
#drawPage-->simply to one functio that can intake data.drawAgain
class Button(object):
    def __init__(self, name, cx, cy, width, height, color):
        self.name=name
        self.x1=cx-width
        self.x2=cx+width
        self.y1=cy-height
        self.y2=cy+height
        self.cx=cx
        self.cy=cy
        self.color=color
    def draw(self, canvas):
        canvas.create_rectangle(self.x1, self.y1, self.x2, self.y2, 
                                fill=self.color)
    def isClicked(self, mouseX, mouseY):
        if (mouseX>=self.x1 and mouseX<=self.x2 and mouseY>=self.y1 and
            mouseY<=self.y2):
            return True
        else:
            return False

class PauseButton(Button):
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, text="Pause")
    def runCommand(self, data):
        data.isPaused=not data.isPaused

class BackButton(Button):
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, text="Back")
    def runCommand(self, data):
        data.isPaused=False
        data.clickedValve=None
        data.clickedButton=None
        
class HelpButton(Button):
    def __init__(self, name, cx, cy, width, height, color, clicked=False):
        super().__init__(name, cx, cy, width, height, color)
        self.clicked=clicked
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, text="?")
    def runCommand(self, data):
        #This must set data.isPaused to not mess with commands from pause button
        self.clicked=not self.clicked
        if self.clicked:
            data.isPaused=True
        else:
            data.isPaused=False
            data.clickedButton=None
    def drawPage(self, canvas, data):
        message=rightJustifyText('''The MONIAC (Monetary National Income 
                                 Analogue Computer) machine, 
                                 also known as the Phillips machine, was first 
                                 created by economist Bill Phillips in 1949 at 
                                 the London School of Economics. The machine 
                                 models the macroeconomy by taking into account 
                                 the various components of Gross Domestic 
                                 Product (GDP)--Consumption, Government 
                                 Spending, Investment, Exports, and Imports, and
                                 can be modelled by the equation GDP=C+I+G+X-M. 
                                 In this simulation of the MONIAC machine, you 
                                 can change the values of various macroeconomic 
                                 variables, which in turn affect how much of the
                                 economy's output flows into each sector. Output
                                 or monetary funds are represented as sand 
                                 objects. You may also view graphs of values 
                                 over time. In the Base Game mode, the effects 
                                 of a single monetary injection in the economy 
                                 is  illustrated, whereas the Loop Game mode 
                                 demonstrates a more accurate representation 
                                 where output continuously flows around the 
                                 macroeconomy. Additionally, you may view what 
                                 each economic sector does by pressing on the 
                                 rectangular "Valves" that take input and 
                                 release output. To go back to the previous 
                                 page, press the help button again.
                                 ''', 50)
        canvas.create_text(data.width/2, data.height/2, text=message)

class MessageButton(Button):
    def __init__(self, name, cx, cy, width, height, color, message, 
                 clicked=False):
        super().__init__(name, cx, cy, width, height, color)
        self.message=message
        self.clicked=clicked
    def draw(self, canvas):
        canvas.create_rectangle(self.x1, self.y1, self.x2, self.y2, fill='')
    def runCommand(self, data):
        #This must set data.isPaused to not mess with commands from pause button
        self.clicked=not self.clicked
        if self.clicked:
            data.isPaused=True
        else:
            data.isPaused=False
            data.clickedButton=None
    def drawPage(self, canvas, data):
        canvas.create_text(data.width/2, data.height/2, text=self.message)

class HomeButton(Button):
    def __init__(self, name, cx, cy, width, height, color, clicked=False):
        super().__init__(name, cx, cy, width, height, color)
        self.clicked=clicked
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, text="Home")
    def runCommand(self, data):
        init(data)
            
class BaseGameButton(Button):
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, text="Begin Base Game")
    def runCommand(self, data):
        data.mode="Base Game"

class LoopGameButton(Button):
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, text="Begin Loop Game")
    def runCommand(self, data):
        data.mode="Loop Game"

class VariableButton(Button):
    def __init__(self, name, cx, cy, width, height, color, value):
        super().__init__(name, cx, cy, width, height, color)
        self.value=value
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, 
                           text='%s: %0.2f'%(self.name, self.value))
    def runCommand(self, data):
        data.isPaused=True
    def drawPage(self, canvas, data):
        if data.drawAgain:
            canvas.create_text(data.width/2, data.height*5/11, 
                               text="Input must be a float between 0 and 1.")
        canvas.create_text(data.width/2, data.height/2, 
                           text='Input New %s'%(self.name))
        canvas.create_text(data.width/2, data.height*6/11, 
                           text=data.buttonInput)
    def updateValue(self, input):
        assert(0<=float(input)<=1)
        self.value=float(input)

class GDPButton(VariableButton):
    def drawPage(self, canvas, data):
        if data.drawAgain:
            message="Input must be a positive integer less than 25."
            canvas.create_text(data.width/2, data.height*5/11, text=message)
        canvas.create_text(data.width/2, data.height/2, 
                           text='Input New %s'%(self.name))
        canvas.create_text(data.width/2, data.height*6/11, 
                           text=data.buttonInput)
    def updateValue(self, input):
        assert(0<=int(input)<=25)
        self.value=float(input)
    
class GraphButton(Button):
    def draw(self, canvas):
        super().draw(canvas)
        canvas.create_text(self.cx, self.cy, text='Show Graph')
    def runCommand(self, data):
        runGraph(data)

##other objects
class Valve(object):
    def __init__(self, name, rate, x1, y1, x2, y2, color, message, 
                 clicked=False):
        self.name=name
        self.rate=rate
        self.x1=x1
        self.y1=y1
        self.x2=x2
        self.y2=y2
        self.color=color
        self.value=0
        self.message=message
        self.clicked=clicked
    def draw(self, canvas):
        x1=self.x1
        y1=self.y1
        x2=self.x2
        y2=self.y2
        canvas.create_rectangle(x1, y1, x2, y2, fill=self.color)
        canvas.create_text((x1+x2)/2, (y1+y2)/2, text=self.value)
    def releaseBalls(self, r, dx, dy, boing):
        ballsReleased=roundUp(self.value*self.rate)
        sandL=[]
        ballGrid=createSandGrid(5, ballsReleased)
        startX=(self.x1+self.x2)/2
        startY=self.y2
        for row in range(len(ballGrid)):
            for col in range(len(ballGrid[row])):
                if ballGrid[row][col]!=None:
                    sand=Sand(startX+r*2*col, startY+r*(2*row+1), r, dx, dy, 
                              boing)
                    sandL.append(sand)
        self.value-=ballsReleased
        return sandL
    def collides(self, cy, cx, r):
        return (cy+r>=self.y1 and cy-r<=self.y2 and cx-r<=self.x2 and 
                cx+r>=self.x1)
    def updateValue(self, newRate):
        self.rate=newRate
    def isClicked(self, mouseX, mouseY):
        if (mouseX>=self.x1 and mouseX<=self.x2 and mouseY>=self.y1 and
            mouseY<=self.y2):
            return True
        else:
            return False
    def runCommand(self, data):
        #This must set data.isPaused to not mess with commands from pause button
        self.clicked=not self.clicked
        if self.clicked:
            data.isPaused=True
        else:
            data.isPaused=False
            data.clickedButton=None
    def drawPage(self, canvas, data):
        canvas.create_text(data.width/2, data.height/2, text=self.message)

class SumValve(Valve):
    def __init__(self, name, rate, x1, y1, x2, y2, color, message, spendingRate,
                 clicked=False):
        super().__init__(name, rate, x1, y1, x2, y2, color, message, clicked)
        self.spendingRate=spendingRate
    def releaseBalls(self, r, dx, dy, boing):
        ballsReleased1=int(self.value*(1-self.rate)*self.spendingRate)
        ballsReleased2=roundUp(self.value*self.rate*self.spendingRate)
        sandL=[]
        ballGrid1=createSandGrid(14, ballsReleased1)
        ballGrid2=createSandGrid(10, ballsReleased2)
        startX1=self.x1+(self.x2-self.x1)/4
        startX2=self.x1+(self.x2-self.x1)*2/3
        startY=self.y2
        for row in range(len(ballGrid1)):
            for col in range(len(ballGrid1[row])):
                if ballGrid1[row][col]!=None:
                    sand=Sand(startX1+r*2*col, startY+r*(2*row+1), r, -dx, dy, 
                              boing)
                    sandL.append(sand)
        for row in range(len(ballGrid2)):
            for col in range(len(ballGrid2[row])):
                if ballGrid2[row][col]!=None:
                    sand=Sand(startX2+r*2*col, startY+r*(2*row+1), r, dx, dy, 
                              boing)
                    sandL.append(sand)
        self.value-=(ballsReleased1+ballsReleased2)
        return sandL

class HorizontalValve(Valve):
    def releaseBalls(self, r, dx, dy, boing):
        ballsReleased=roundUp(self.value*self.rate)
        sandL=[]
        ballGrid=createSandGrid(6, ballsReleased)
        startX=self.x1-r
        startY=(self.y1+self.y2)/2
        for row in range(len(ballGrid)):
            for col in range(len(ballGrid[row])):
                if ballGrid[row][col]!=None:
                    sand=Sand(startX-r*2*col, startY+r*(2*row+1), r, -abs(dx), 
                              dy, boing)
                    sandL.append(sand)
        self.value-=ballsReleased
        return sandL

## MVC
def init(data):
    #initialize macroeconomic variables
    #data.GDP=5000
    data.GDP=100
    data.fixedGDP=10
    data.interestRate=0.02
    data.lendingRate=0.5
    data.taxRate=0.05
    data.importRate=0.5
    data.exportRate=0.5
    data.govSpendingRate=0.5
    data.spendingRate=0.5
    
    #initialize colors
    data.consumerColor='red'
    data.govColor='turquoise'
    data.bankColor='green'
    data.dsColor='orange'
    data.foreignColor='purple'
    data.neutralColor='white'
    
    #initialize background objects
    data.newX=data.width*2/3
    data.walls=initializeWalls(data)
    data.buttons=initializeMainButtons(data)
    data.helpButton=HelpButton("Help Button", data.width*8/9, data.height/11, 
                               data.width/15, data.height/25, data.neutralColor)
    data.homeButton=HomeButton("Home Button", data.width*8/9, data.height*2/11, 
                               data.width/15, data.height/25, data.neutralColor)
    data.backButton=BackButton("Back Button", data.width/2, data.height/11,
                               data.width/10, data.height/11, data.neutralColor)
    data.gdpButton=GDPButton("GDP", data.width*8/9, data.height*5/11, 
                             data.width/15, data.height/25, data.neutralColor, 
                             data.fixedGDP)
    data.startButtons=initializeStartButtons(data)
    data.valves=initializeValves(data)
    data.labels=initializeLabels(data)
    data.title=Label("Simple MONIAC Macroeconomy Educational Simulator",
                     data.width/2, data.height/4, 'black')
    
    #initialize sand
    data.dx = 0.5
    data.dy = 1
    data.gravity=2
    data.boing = 0.3
    data.xboing=0.7
    data.radius=3
    data.sand=[]
    
    #graph stuff
    data.cValues=[0]
    data.tValues=[0]
    data.gValues=[0]
    data.sValues=[0]
    data.iValues=[0]
    data.dsValues=[0]
    data.mValues=[0]
    data.xValues=[0]
    data.timerFiredCount=0
    
    #pausing and modes
    data.mode="Start Screen"
    data.isPaused=False
    data.clickedValve=None
    data.clickedButton=None
    data.buttonInput=''
    data.drawAgain=False
    data.timerDelay = 10

##Sand
def initializeGovSand(data, gdp):
    sandL=[]
    govGrid=createSandGrid(8, roundUp(gdp*data.taxRate))
    startX=data.newX/20
    startY=data.newX/20
    for row in range(len(govGrid)):
        for col in range(len(govGrid[row])):
            if govGrid[row][col]!=None:
                sand=Sand(startX+data.radius*2*col, startY+data.radius*2*row, 
                          data.radius, data.dx, data.dy, data.boing)
                sandL.append(sand)
    return sandL

def initializeConSand(data, gdp):
    sandL=[]
    consumptionGrid=createSandGrid(32, gdp-len(initializeGovSand(data, gdp))-
                                   len(initializeSavingSand(data, gdp)))
    startX=data.newX*2/5
    startY=data.newX/20
    for row in range(len(consumptionGrid)):
        for col in range(len(consumptionGrid[row])):
            if consumptionGrid[row][col]!=None:
                sand=Sand(startX+data.radius*2*col, startY+data.radius*2*row, 
                          data.radius, data.dx, data.dy, data.boing)
                sandL.append(sand)
    return sandL
    
def initializeSavingSand(data, gdp):
    sandL=[]
    savingGrid=createSandGrid(4, roundUp(gdp*data.interestRate))
    startX=data.newX*7/10
    startY=data.newX/20
    for row in range(len(savingGrid)):
        for col in range(len(savingGrid[row])):
            if savingGrid[row][col]!=None:
                sand=Sand(startX+data.radius*2*col, startY+data.radius*2*row, 
                          data.radius, data.dx, data.dy, data.boing)
                sandL.append(sand)
    return sandL

def createSandGrid(cols, balls):
    L=[]
    while balls>0:
        if balls>=cols:
            L.extend([[0]*(cols)])
            balls-=cols
        else:
            L.extend([[0]*(balls%cols)+[None]*(cols-balls%cols)])
            balls-=balls%cols
    return L

##Valves, Walls, Buttons
def initializeValves(data):
    #Creates valves
    govMessage=rightJustifyText('''The government sector comprises of the 
                                government, which receives tax revenue from 
                                households and uses that revenue as part of its 
                                budget, which it may spend on social projects.
                                This is spent in the form of government 
                                spending, which deducts from the government's 
                                budget. The government's budget is shown by the 
                                this valve, and can be adjusted by modifying the 
                                tax rate and rate of government spending.
                                ''', 50)
    govValve=Valve("GovSector", data.govSpendingRate, 0, data.height/3, 
                   data.newX/6, data.height*4/9, data.govColor, govMessage)
    bankMessage=rightJustifyText('''The financial sector comprises of the 
                                 central bank and various independent banks. By
                                 adjusting the interest rate, the Central Bank 
                                 is able to increase/decrease the amount of 
                                 money individuals save, thereby changing the 
                                 supply of money as well as how much is lent.
                                 ''', 50)
    bankValve=Valve("FinancialSector", data.lendingRate, data.newX*5/6, 
                    data.height*7/18, data.newX, data.height/2, data.bankColor, 
                    bankMessage)
    foreignMessage=rightJustifyText('''The foreign sector comprises of goods and
                                    services traded with foreign countries. 
                                    Exports are goods/services that are produced
                                    domestically and sold abroad, while imports
                                    are goods/services produced abroad and sold 
                                    domestically. The amount of each traded is 
                                    determined by the country's currency 
                                    exchange rate, but in this model is 
                                    simplified to be the import rate and export
                                    rate.
                                    ''', 50)
    foreignValve=HorizontalValve("ForeignSector", data.exportRate, 
                                 data.newX*3/4, data.height*14/18*11/10, 
                                 data.newX*17/18, data.height*14/18*11/10*16/15,
                                 data.foreignColor, foreignMessage)
    dsMessage=rightJustifyText('''This valve represents the total amount of 
                               monetary injections in the economy excluding the
                               foreign sector, i.e. domestic spending. Adjusting
                               the import rate will determine how much of these
                               injections enter the foreign sector.
                               ''', 50)
    domSpendingValve=SumValve("TotalSpendingSector", data.importRate, 
                              data.newX/3, data.height/2, data.newX*2/3, 
                              data.height*12/18, data.dsColor, dsMessage, 
                              data.spendingRate)
    consumptionMessage=rightJustifyText('''This represents all consumer spending
                                        in the economy. Consumers spend money to
                                        purchase goods and services. In this 
                                        model, the rate of consumption is 
                                        calculated as total income minus the 
                                        amount saved in banks and the amount 
                                        paid as taxes to the government--in 
                                        essence, the remaining income after 
                                        these deductions represents disposable 
                                        income, which is spent by consumers.
                                        ''', 50)
    conValve=Valve("ConsumerSector", 1, data.newX/3, data.height/3, 
                           data.newX*2/3, data.height/3*1.2, data.consumerColor,
                           consumptionMessage)
    return [govValve, bankValve, foreignValve, domSpendingValve, conValve]

def initializeWalls(data):
    #creates walls with amazing hard code
    #border wall
    wall0=Wall(data.newX, 0, data.newX, data.height)
    #G trapezoid
    wall1=Wall(data.newX/3, data.height/18, data.newX/3, data.height/2)
    wall2=Wall(data.newX/6, data.height/3, data.newX/3, data.height/9)
    wall3=Wall(data.newX/6, data.height/3, data.newX/6, data.height*4/9)
    wall4=Wall(data.newX/6, data.height*4/9, data.newX/3, data.height/2)
    #G bottom
    wall5=Wall(0, data.height*5/9, data.newX/3, data.height*2/3)
    wall6=Wall(data.newX/3, data.height*2/3, data.newX/3, data.height)
    #S trapezoid
    wall7=Wall(data.newX*2/3, data.height/9, data.newX*2/3, data.height*5/9)
    wall8=Wall(data.newX*2/3, data.height/3, data.newX*5/6, data.height*7/18)
    wall9=Wall(data.newX*5/6, data.height*7/18, data.newX*5/6, data.height/2)
    wall10=Wall(data.newX*5/6, data.height/2, data.newX*2/3, data.height*5/9)
    #I triangle
    wall11=Wall(data.newX*2/3, data.height*12/18, data.newX*17/18, 
                data.height*31/54)
    wall12=Wall(data.newX*17/18, data.height*15/18, data.newX*2/3, 
                data.height*12/18)
    wall13=Wall(data.newX*17/18, data.height/2, data.newX*17/18, 
                data.height*616/675)
    #MX triangle
    wall14=Wall(data.newX/2, data.height*1243/1800, data.newX/2, 
                data.height*8/9)
    wall15=Wall(data.newX/2, data.height*1243/1800, data.newX*3/4, 
                data.height*77/90)
    wall16=Wall(data.newX*3/4, data.height*77/90, data.newX/2, data.height*8/9)
    #MX base trapezoid
    wall17=Wall(data.newX*3/4, data.height*616/675, data.newX/2, 
                data.height*128/135)
    wall18=Wall(data.newX*3/4, data.height*616/675, data.newX*5/6, 
                data.height*616/675)
    return [wall0, wall1, wall2, wall3, wall4, wall5, wall6, wall7, wall8, 
            wall9, wall10, wall11, wall12, wall13, wall14, wall15, wall16, 
            wall17, wall18]

def initializeLabels(data):
    taxLabel=Label("Gov. Tax Income", data.newX/6, data.height/9, data.govColor)
    gSpendingLabel=Label("Gov. Spending", data.newX/6, data.height/2, 
                         data.govColor)
    consumptionLabel=Label("Consumer Spending", data.newX/2, data.height/6, 
                           data.consumerColor)
    savingLabel=Label("Saving", data.newX*5/6, data.height/6, data.bankColor)
    investmentLabel=Label("Investment", data.newX*5/6, data.height*6/11, 
                          data.bankColor)
    importLabel=Label("Imports", data.newX*7/9, data.height*4/5, 
                      data.foreignColor)
    exportLabel=Label("Exports", data.newX*7/10, data.height*22/25, 
                      data.foreignColor)
    return [taxLabel, gSpendingLabel, consumptionLabel, savingLabel, 
            investmentLabel, importLabel, exportLabel]

def initializeStartButtons(data):
    #creates start screen buttons
    bWidth=data.width/10
    bHeight=data.height/25
    xPos=data.width/2
    baseGameButton=BaseGameButton("Base Game Button", xPos, data.height*5/11, 
                                  bWidth, bHeight, data.neutralColor)
    loopGameButton=LoopGameButton("Loop Game Button", xPos, data.height*7/11, 
                                  bWidth, bHeight, data.neutralColor)
    return [baseGameButton, loopGameButton]

def initializeMainButtons(data):
    #creates main game buttons with more amazing hard code
    bWidth=data.width/15
    bHeight=data.height/25
    xPos=data.width*8/9
    #Pause Button
    pButton=PauseButton("Pause Button", xPos, data.height*3/11, bWidth, bHeight,
                        data.neutralColor)
    #Variable Buttons
    iButton=VariableButton("Interest Rt", xPos, data.height*6/11, bWidth, 
                           bHeight, data.bankColor, data.interestRate)
    tButton=VariableButton("Tax Rt", xPos, data.height*7/11, bWidth, bHeight,
                           data.govColor, data.taxRate)
    gButton=VariableButton("Gov. Spending Rt", xPos, data.height*8/11, bWidth,
                           bHeight, data.govColor, data.govSpendingRate)
    mButton=VariableButton("Import Rt", xPos, data.height*9/11, bWidth, bHeight,
                           data.foreignColor, data.importRate)
    xButton=VariableButton("Export Rt", xPos, data.height*10/11,
                           bWidth, bHeight, data.foreignColor, data.exportRate)
    #Graph Button
    graphButton=GraphButton("Graph Button", xPos, data.height*4/11, bWidth, 
                            bHeight, data.neutralColor)
    return [pButton, iButton, tButton, mButton, xButton, gButton, graphButton]

##Animation Framework
def timerFired(data):
    if data.mode=='Loop Game':
        if data.gdpButton not in data.buttons:
            data.buttons.append(data.gdpButton)
    if not data.isPaused:
        loopDoStep(data)
        data.timerFiredCount+=1
        if data.timerFiredCount%10==0:
            releaseValves(data)
            if data.mode=="Loop Game":
                data.sand.extend(initializeConSand(data, data.fixedGDP)+
                                    initializeSavingSand(data, data.fixedGDP)+
                                    initializeGovSand(data, data.fixedGDP))

def loopDoStep(data):
    i=0
    while i<(len(data.sand)):
        data.sand[i].move()
        data.sand[i].updateAngle()
        #wall collisions and bouncing
        for wall in data.walls:
            if data.sand[i].collides(wall):
                if wall.slope==0:
                    #reverse x if collides with vertical wall
                    if data.sand[i].dx>0:
                        data.sand[i].cx=wall.x1-data.sand[i].r
                    else:
                        data.sand[i].cx=wall.x1+data.sand[i].r
                    data.sand[i].unmoveX()
                else:
                    #set height to line and reverse dy
                    data.sand[i].cy=wall.slope*(data.sand[i].cx-wall.x1)+wall.y1
                    if data.sand[i].dy<0:
                        data.sand[i].cy+=data.sand[i].r
                    else:
                        data.sand[i].cy-=data.sand[i].r
                    
                    #modify angle
                    data.sand[i].angle=(wall.angle-math.pi+data.sand[i].angle)
                    data.sand[i].angle%=(2*math.pi)
                    
                    #modify dx
                    if data.sand[i].dx==0:
                        if (0<data.sand[i].angle<math.pi/2 or 
                            math.pi<data.sand[i].angle<3*math.pi/2):
                            data.sand[i].dx=1
                        else:
                            data.sand[i].dx=-1
                    else:
                        data.sand[i].dx/=data.xboing
                    
                    #move
                    data.sand[i].unmoveY()
                    data.sand[i].moveX()
                    
                #stop moving
                if abs(data.sand[i].dy)<2:
                    data.sand[i].dx*=data.xboing
        
        #boundary bouncing
        if (data.sand[i].cx-data.sand[i].r<=0 or 
            data.sand[i].cx+data.sand[i].r>=data.width):
            data.sand[i].unmoveX()
            #stop dy
            if abs(data.sand[i].dy)<2:
                data.sand[i].dx=0
        if data.sand[i].cy-data.sand[i].r<=0:
            data.sand[i].unmoveY()
            #stop dy
            if abs(data.sand[i].dy)<2:
                data.sand[i].dx=0
        elif data.sand[i].cy+data.sand[i].r>=data.height:
            data.sand.pop(i)
        data.sand[i].dy+=data.gravity
        
        #valve reactions
        collided=False
        for valve in data.valves:
            if valve.collides(data.sand[i].cy, data.sand[i].cx, data.sand[i].r):
                valve.value+=1
                data.sand.pop(i)
                collided=True
                break
        if collided==False:
            i+=1

def releaseValves(data):
    for valve in data.valves:
        if valve.name=="GovSector":
            data.tValues.append(valve.value)
        elif valve.name=="FinancialSector":
            data.sValues.append(valve.value)
        elif valve.name=="ForeignSector":
            data.mValues.append(valve.value)
        result=valve.releaseBalls(data.radius, 0.5, 1, data.boing)
        if valve.name=="ConsumerSector":
            data.cValues.append(len(result))
        elif valve.name=="TotalSpendingSector":
            data.dsValues.append(len(result))
        elif valve.name=="GovSector":
            data.gValues.append(len(result))
        elif valve.name=="ForeignSector":
            data.xValues.append(len(result))
        elif valve.name=="FinancialSector":
            data.iValues.append(len(result))
        data.sand.extend(result)

def extendSand(data):
    if data.mode=="Base Game":
        data.sand.extend(initializeConSand(data, data.GDP)+
                         initializeSavingSand(data, data.GDP)+
                         initializeGovSand(data, data.GDP))
    else:
        data.sand.extend(initializeConSand(data, data.fixedGDP)+
                         initializeSavingSand(data, data.fixedGDP)+
                         initializeGovSand(data, data.fixedGDP))

def mousePressed(event, data):
    #mouse and button interactions will mainly be here
    #Start Screen buttons
    if data.mode=="Start Screen":
        if data.clickedButton==None:
            for button in data.startButtons:
                if button.isClicked(event.x, event.y):
                    data.clickedButton=button
                    button.runCommand(data)
                    extendSand(data)
                    
    #Game Mode buttons
    else:
        if data.clickedButton==None or not isinstance(data.clickedButton, 
                                                      VariableButton):
            for button in data.buttons:
                if button.isClicked(event.x, event.y):
                    data.clickedButton=button
                    button.runCommand(data)
        if data.clickedValve==None:
            for valve in data.valves:
                if valve.isClicked(event.x, event.y):
                    data.clickedValve=valve
                    valve.runCommand(data)
        else:
            if data.backButton.isClicked(event.x, event.y):
                data.backButton.runCommand(data)
    #Always existing buttons
    if data.helpButton.isClicked(event.x, event.y):
        data.clickedButton=data.helpButton
        data.helpButton.runCommand(data)
    if data.homeButton.isClicked(event.x, event.y):
        data.clickedButton=data.homeButton
        data.homeButton.runCommand(data)
        
def keyPressed(event, data):
    if data.clickedButton!=None:
        if event.keysym=="Return":
            try:
                data.clickedButton.updateValue(data.buttonInput)
                if data.clickedButton.name=="Interest Rt":
                    data.interestRate=float(data.buttonInput)
                elif data.clickedButton.name=="Tax Rt":
                    data.taxRate=float(data.buttonInput)
                elif data.clickedButton.name=="Import Rt":
                    data.importRate=float(data.buttonInput)
                    data.valves[3].updateValue(data.importRate)
                elif data.clickedButton.name=="Export Rt":
                    data.exportRate=float(data.buttonInput)
                    data.valves[2].updateValue(data.exportRate)
                elif data.clickedButton.name=="Gov. Spending Rt":
                    data.govSpendingRate=float(data.buttonInput)
                    data.valves[0].updateValue(data.govSpendingRate)
                elif data.clickedButton.name=="GDP":
                    data.fixedGDP=int(data.buttonInput)
                assert(data.interestRate+data.taxRate<=1)
                data.clickedButton=None
                data.isPaused=False
                data.buttonInput=''
                data.drawAgain=False
            except:
                data.drawAgain=True
                data.buttonInput=''
        else:
            data.buttonInput+=str(event.char)

def redrawAll(canvas, data):
    data.helpButton.draw(canvas)
    data.homeButton.draw(canvas)
    if data.clickedButton==data.helpButton:
        data.helpButton.drawPage(canvas, data)
    else:
        if data.mode=="Start Screen":
            for button in data.startButtons:
                button.draw(canvas)
            data.title.draw(canvas)

        else:
            if data.clickedButton==None:
                if data.clickedValve==None:
                    for wall in data.walls:
                        wall.draw(canvas)
                    for button in data.buttons:
                        button.draw(canvas) 
                    for valve in data.valves:
                        valve.draw(canvas)
                    for sand in data.sand:
                        sand.draw(canvas)
                    for label in data.labels:
                        label.draw(canvas)
            if isinstance(data.clickedButton, VariableButton):
                data.clickedButton.drawPage(canvas, data)
            elif data.clickedValve!=None:
                data.clickedValve.drawPage(canvas, data)
                data.backButton.draw(canvas)
            else:
                for button in data.buttons:
                    button.draw(canvas) 
                for wall in data.walls:
                    wall.draw(canvas)
                for valve in data.valves:
                    valve.draw(canvas)
                for sand in data.sand:
                    sand.draw(canvas)
                for label in data.labels:
                    label.draw(canvas)

## Graph functions
def runGraph(data):
    #Creates and handles graphs; Half-inspired by 
    #https://matplotlib.org/gallery/user_interfaces/embedding_in_tk_sgskip.html
    root = tkinter.Tk()
    root.wm_title("MONIAC Graphs")
    fig = Figure(figsize=(10, 8), dpi=100)

    #background subplot
    superGraph=fig.add_subplot(111)
    superGraph.set_xlabel('Time')
    superGraph.set_ylabel('USD')
    # Turn off axis lines and ticks of the big subplot
    superGraph.spines['top'].set_color('none')
    superGraph.spines['bottom'].set_color('none')
    superGraph.spines['left'].set_color('none')
    superGraph.spines['right'].set_color('none')
    superGraph.tick_params(labelcolor='w', top='off', bottom='off', left='off', 
                           right='off')
    
    #Main graphs
    graph1=fig.add_subplot(421)
    graph2=fig.add_subplot(422)
    graph3=fig.add_subplot(423)
    graph4=fig.add_subplot(424)
    graph5=fig.add_subplot(425)
    graph6=fig.add_subplot(426)
    graph7=fig.add_subplot(427)
    graph8=fig.add_subplot(428)
    #set titles
    graph1.set_title('Consumption')
    graph2.set_title('Tax Income')
    graph3.set_title('Gov Spending')
    graph4.set_title('Saving')
    graph5.set_title('Investment')
    graph6.set_title('Total Domestic Spending')
    graph7.set_title('Imports')
    graph8.set_title('Exports')
    #set values
    time=np.array([i for i in range(len(data.cValues))])
    graph1.plot(time, np.array(data.cValues))
    graph2.plot(time, np.array(data.tValues))
    graph3.plot(time, np.array(data.gValues))
    graph4.plot(time, np.array(data.sValues))
    graph5.plot(time, np.array(data.iValues))
    graph6.plot(time, np.array(data.dsValues))
    graph7.plot(time, np.array(data.mValues))
    graph8.plot(time, np.array(data.xValues))
    
    fig.subplots_adjust(left=None, bottom=0.1, right=None, top=0.9, wspace=None,
                        hspace=0.5)
    
    #Plotting code in tkinter
    canvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.
    canvas.draw()
    canvas.get_tk_widget().pack(side=tkinter.TOP, fill=tkinter.BOTH, expand=1)
    
    toolbar = NavigationToolbar2Tk(canvas, root)
    toolbar.update()
    canvas.get_tk_widget().pack(side=tkinter.TOP, fill=tkinter.BOTH, expand=1)
    
    def on_key_press(event):
        print("you pressed {}".format(event.key))
        key_press_handler(event, canvas, toolbar)
    
    canvas.mpl_connect("key_press_event", on_key_press)
    
    def _quit():
        root.quit()     # stops mainloop
        root.destroy()  # this is necessary on Windows to prevent
                        # Fatal Python Error: PyEval_RestoreThread: NULL tstate
    button = tkinter.Button(master=root, text="Quit", command=_quit)
    button.pack(side=tkinter.BOTTOM)
    
    tkinter.mainloop()
    # If you put root.destroy() here, it will cause an error if the window is
    # closed with the window manager.

## Run Functions
def runAnimation(width=1200, height=600):
    def redrawAllWrapper(canvas, data):
        canvas.delete(ALL)
        canvas.create_rectangle(0, 0, data.width, data.height,
                                fill='white', width=0)
        redrawAll(canvas, data)
        canvas.update()

    def mousePressedWrapper(event, canvas, data):
        mousePressed(event, data)
        redrawAllWrapper(canvas, data)

    def keyPressedWrapper(event, canvas, data):
        keyPressed(event, data)
        redrawAllWrapper(canvas, data)

    def timerFiredWrapper(canvas, data):
        timerFired(data)
        redrawAllWrapper(canvas, data)
        # pause, then call timerFired again
        canvas.after(data.timerDelay, timerFiredWrapper, canvas, data)
    # Set up data and call init
    class Struct(object): pass
    data = Struct()
    data.width = width
    data.height = height
    data.timerDelay = 100 # milliseconds
    root = Tk()
    root.title("MONIAC Main")
    init(data)
    # create the root and the canvas
    canvas = Canvas(root, width=data.width, height=data.height)
    canvas.configure(bd=0, highlightthickness=0)
    canvas.pack()
    # set up events
    root.bind("<Button-1>", lambda event:
                            mousePressedWrapper(event, canvas, data))
    root.bind("<Key>", lambda event:
                            keyPressedWrapper(event, canvas, data))
    timerFiredWrapper(canvas, data)
    # and launch the app
    #runGraph(data)
    root.mainloop()  # blocks until window is closed
    print("bye!")

runAnimation()
